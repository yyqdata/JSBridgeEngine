package com.tvt.lib_processor

import com.google.auto.service.AutoService
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.tvt.lib_annotation.annotation.JCall
import com.tvt.lib_annotation.annotation.JRegister
import com.tvt.lib_processor.bean.JAnnotationElement
import com.tvt.lib_processor.bean.JCallElement
import com.tvt.lib_processor.bean.JRegisterElement
import javax.annotation.processing.*
import javax.lang.model.SourceVersion
import javax.lang.model.element.ElementKind
import javax.lang.model.element.ExecutableElement
import javax.lang.model.element.TypeElement
import javax.lang.model.type.TypeKind
import javax.lang.model.type.TypeMirror
import javax.lang.model.util.Elements
import javax.lang.model.util.Types
import javax.tools.Diagnostic

/**
 * @author YYQ
 * @date 2022/4/15  17:28
 * @fileName JSBridgeProcessor
 * @description: JSBridge 注解处理器
 */
@AutoService(Processor::class)
class JSBridgeProcessor : AbstractProcessor() {
    private val supportAnnotations = arrayOf(
        JRegister::class.java,
        JCall::class.java,
//        JWbTarget::class.java //该注解的作用和databinding、黄油刀重复，暂时不作处理
    )

    //    com.github.lzyzsd.jsbridge.BridgeWebView

    private val jsBridgeEngine = "JsBridgeEngine"

    private val bridgeWebView = "bridgeWebView"

    private lateinit var filer: Filer

    private lateinit var messager: Messager

    private lateinit var elementUtils: Elements

    private lateinit var typeUtils: Types


    private val jsBridgeEngineClassNames =
        mutableMapOf<String, ClassName>() // 每个模块包名对应一个 JSBridgeEngine 类

    private val jsBridgeEngineObjects =
        mutableMapOf<String, MutableList<ClassName>>() // 每个 JSBridgeEngine 类中持有注解所在类对象 该对象不建议使用四大组件（会重新创建，丢失数据）

    private val jRegisterElements = mutableMapOf<String, MutableList<JRegisterElement>>()
    private val jCallElements = mutableMapOf<String, MutableList<JCallElement>>()

    private var firstProcess = true

    override fun init(p0: ProcessingEnvironment?) {
        super.init(p0)
        p0?.let {
            filer = it.filer
            messager = it.messager
            elementUtils = it.elementUtils
            typeUtils = it.typeUtils
            messager.printMessage(Diagnostic.Kind.NOTE, "JSBridgeProcessor init...")
        }
    }

    override fun getSupportedAnnotationTypes(): MutableSet<String> {
        val annotations = LinkedHashSet<String>()
        supportAnnotations.forEach {
            annotations.add(it.canonicalName)
        }
        return annotations
    }

    override fun getSupportedSourceVersion(): SourceVersion {
        return SourceVersion.latestSupported()
    }

    override fun process(p0: MutableSet<out TypeElement>?, p1: RoundEnvironment?): Boolean {
        if (p0 == null || p0.isEmpty()) return true
        if (!firstProcess) return true
        firstProcess = false
        if (!findElements(p1)) return true
        messager.printMessage(
            Diagnostic.Kind.NOTE,
            "$jsBridgeEngineClassNames , $jsBridgeEngineObjects"
        )
        messager.printMessage(
            Diagnostic.Kind.NOTE,
            "$jRegisterElements , $jCallElements"
        )
        generateKtFile()
//        mock()
        return true
    }

    /**
     * @author YYQ
     * @date 2022/4/25  10:10
     * @description 生成对应的kotlin文件
     */
    private fun generateKtFile() {
        jsBridgeEngineClassNames.forEach { (pkg, className) ->
            val fBuilder = FileSpec.builder(pkg, className.simpleName)
                .addFileComment("This file is auto generated by JSBridgeProcessor!Do not edit!")
            generateMethodAndObjs(fBuilder, className)
            fBuilder.build().writeTo(filer)
        }
    }

    /**
     * @author YYQ
     * @date 2022/4/25  11:05
     * @description 生成文件内容
     */
    private fun generateMethodAndObjs(builder: FileSpec.Builder, className: ClassName) {
        val engineTypeBuilder = TypeSpec.objectBuilder(className.simpleName)

        // 添加启动函数
        val startFunBuilder = FunSpec.builder("start")
            .addParameter(bridgeWebView, Constants.bridgeWebView)

        // 添加对象属性
        val objects = jsBridgeEngineObjects[className.packageName + "_$jsBridgeEngine"]
        objects?.forEach {
            val propertyName = it.simpleName + "_field"
            val propertySpec = PropertySpec.builder(propertyName, it)
                .addModifiers(KModifier.PUBLIC)
                .initializer("%T()", it)
                .build()
            engineTypeBuilder.addProperty(propertySpec)
            val classPath = it.packageName + "_${it.simpleName}"
            // JRegister 注册函数
            val methodList = jRegisterElements[classPath]
            methodList?.forEach { element ->
                val registName =
                    element.registerName.ifEmpty { element.elementName }
                val paramsArray: Array<String> =
                    if (element.registerNeedData && element.registerNeedCallback) {
                        arrayOf("data", "function") //默认参数排序
                    } else if (!element.registerNeedData && !element.registerNeedCallback) {
                        emptyArray()
                    } else {
                        arrayOf("data")
                    }
                if (checkElementIsExecuteMethod(element)) {
                    val params = (element.element as ExecutableElement).parameters
                    params.forEachIndexed { index, variableElement ->
                        if (variableElement.asType().isString()) paramsArray[index] = "data"
                        if (variableElement.asType().isCallBackFunction()) paramsArray[index] =
                            "function"
                    }
                }
                val paramStatement = when (paramsArray.size) {
                    0 -> "()"
                    1 -> "(${paramsArray[0]})"
                    2 -> "(${paramsArray[0]}, ${paramsArray[1]})"
                    else -> "()"
                }
                val registerFun =
                    if (element.registerIsDefaultHandler) "setDefaultHandler" else "registerHandler(%S)"
                startFunBuilder.addStatement(
                    """
                    |
                    |$bridgeWebView.$registerFun { data, function ->
                    |   $propertyName.${element.elementName}$paramStatement
                    |}
                """.trimMargin(),
                    registName
                )
            }
            //JCall 添加扩展函数
            val methodList2 = jCallElements[classPath]
            methodList2?.forEach { element ->
                val callName = element.callName.ifEmpty { element.elementName }
                val paramsArray: Array<String> =
                    if (element.callNeedData) {
                        arrayOf("data") //默认参数排序
                    } else {
                        emptyArray()
                    }
                val paramStatement = when (paramsArray.size) {
                    0 -> "()"
                    1 -> "(${paramsArray[0]})"
                    else -> "()"
                }
                val externalFun = FunSpec.builder(callName)
                    .receiver(Constants.bridgeWebView)
                    .addParameter("dataToJs", String::class)
                    .addStatement(
                        """
                            |
                            |callHandler(%S, dataToJs) { data ->
                            |   $jsBridgeEngine.$propertyName.${element.elementName}$paramStatement
                            |}
                        """.trimMargin(),
                        callName
                    )
                    .build()
                builder.addFunction(externalFun)
            }
        }

        engineTypeBuilder.addFunction(startFunBuilder.build())
        builder.addType(engineTypeBuilder.build())
    }

    /**
     * @author YYQ
     * @date 2022/4/19  15:04
     * @description 遍历注解
     */
    private fun findElements(
        p1: RoundEnvironment?
    ): Boolean {
        supportAnnotations.forEach {
            p1?.getElementsAnnotatedWith(it)?.forEach { element ->
                val jAnnotationElement: JAnnotationElement = when (it) {
                    JRegister::class.java -> JRegisterElement(element, elementUtils)
                    JCall::class.java -> JCallElement(element, elementUtils)
                    else -> JRegisterElement(element, elementUtils)
                }
                if (!checkElement(jAnnotationElement)) return false
                messager.printMessage(Diagnostic.Kind.NOTE, "找到正确注解元素: $jAnnotationElement")
                // 保存所有的 Engine 类 用来生成不同 module 中的类文件
                val pkgName = jAnnotationElement.pkgName
                if (jsBridgeEngineClassNames.containsKey(pkgName)) {
                    if (jsBridgeEngineClassNames[pkgName] == null) {
                        jsBridgeEngineClassNames[pkgName] = ClassName(pkgName, jsBridgeEngine)
                    }
                } else {
                    jsBridgeEngineClassNames[pkgName] = ClassName(pkgName, jsBridgeEngine)
                }
                // 保存 每个 Engine 类中的 注解所在类对象
                val enginePath = "${pkgName}_$jsBridgeEngine"
                if (jsBridgeEngineObjects.containsKey(enginePath)) {
                    var objects = jsBridgeEngineObjects[enginePath]
                    if (objects == null) {
                        objects = mutableListOf()
                        jsBridgeEngineObjects[enginePath] = objects
                    }
                    val className = ClassName(pkgName, jAnnotationElement.enclosingElementName)
                    if (!objects.contains(className)) objects.add(className)
                } else {
                    jsBridgeEngineObjects[enginePath] = mutableListOf()
                    val className = ClassName(pkgName, jAnnotationElement.enclosingElementName)
                    if (!jsBridgeEngineObjects[enginePath]?.contains(className)!!)
                        jsBridgeEngineObjects[enginePath]?.add(className)
                }
                // 保存 方法名和 包名_类名 键值对
                val classPath = "${pkgName}_${jAnnotationElement.enclosingElementName}"
                if (jRegisterElements[classPath] == null) {
                    jRegisterElements[classPath] = mutableListOf()
                }
                if (jCallElements[classPath] == null) {
                    jCallElements[classPath] = mutableListOf()
                }
                if (jAnnotationElement is JRegisterElement) {
                    jRegisterElements[classPath]?.add(jAnnotationElement)
                }
                if (jAnnotationElement is JCallElement) {
                    jCallElements[classPath]?.add(jAnnotationElement)
                }
            }
        }
        return true
    }

    /**
     * @author YYQ
     * @date 2022/4/24  10:32
     * @description 检查注解参数和对应的注解函数是否匹配
     */
    private fun checkElement(jAnnotationElement: JAnnotationElement): Boolean {
        if (!checkElementIsExecuteMethod(jAnnotationElement)) return false
        val executableElement = jAnnotationElement.element as ExecutableElement
        when (jAnnotationElement) {
            is JRegisterElement -> { // 检查 JRegister 注解
                val needData = jAnnotationElement.registerNeedData
                val needCallback = jAnnotationElement.registerNeedCallback
                val parameters = executableElement.parameters
                if (parameters.size > 2) {
                    messager.printMessage(
                        Diagnostic.Kind.ERROR,
                        "@JRegister 要求被注解函数参数不能超过2个！class: ${jAnnotationElement.enclosingElementName}, method: ${jAnnotationElement.elementName}"
                    )
                    return false
                }
                if (parameters.size == 0 && (needData || needCallback)) {
                    messager.printMessage(
                        Diagnostic.Kind.ERROR,
                        "@JRegister 要求被注解函数参数不能为0个！class: ${jAnnotationElement.enclosingElementName}, method: ${jAnnotationElement.elementName}"
                    )
                    return false
                }
                if (parameters.size > 1 && needData != needCallback) {
                    messager.printMessage(
                        Diagnostic.Kind.ERROR,
                        "@JRegister 要求被注解函数参数为1个！class: ${jAnnotationElement.enclosingElementName}, method: ${jAnnotationElement.elementName}"
                    )
                    return false
                }
                if (parameters.size > 0 && !needData && !needCallback) {
                    messager.printMessage(
                        Diagnostic.Kind.ERROR,
                        "@JRegister 要求被注解函数参数为0个！class: ${jAnnotationElement.enclosingElementName}, method: ${jAnnotationElement.elementName}"
                    )
                    return false
                }
                val fitRes = booleanArrayOf(false, false)
                parameters.forEach {
                    if (it.asType().isString()) fitRes[0] = true
                    if (it.asType().isCallBackFunction()) fitRes[1] = true
                }
                if (!fitRes[0] && needData) {
                    messager.printMessage(
                        Diagnostic.Kind.ERROR,
                        "@JRegister 要求被注解函数参数必须有一个 String 类型参数！class: ${jAnnotationElement.enclosingElementName}, method: ${jAnnotationElement.elementName}"
                    )
                    return false
                }
                if (!fitRes[1] && needCallback) {
                    messager.printMessage(
                        Diagnostic.Kind.ERROR,
                        "@JRegister 要求被注解函数参数必须有一个 CallBackFunction 类型参数！class: ${jAnnotationElement.enclosingElementName}, method: ${jAnnotationElement.elementName}"
                    )
                    return false
                }
            }
            is JCallElement -> { // 检查 JCall 注解
                val needData = jAnnotationElement.callNeedData
                val parameters = executableElement.parameters
                if (parameters.size > 1) {
                    messager.printMessage(
                        Diagnostic.Kind.ERROR,
                        "@JCall 要求被注解函数参数不能超过1个！class: ${jAnnotationElement.enclosingElementName}, method: ${jAnnotationElement.elementName}"
                    )
                    return false
                }
                if (parameters.size == 0 && needData) {
                    messager.printMessage(
                        Diagnostic.Kind.ERROR,
                        "@JCall 要求被注解函数参数不能为0个！class: ${jAnnotationElement.enclosingElementName}, method: ${jAnnotationElement.elementName}"
                    )
                    return false
                }
                if (parameters.size > 0 && !needData) {
                    messager.printMessage(
                        Diagnostic.Kind.ERROR,
                        "@JCall 要求被注解函数参数为0个！class: ${jAnnotationElement.enclosingElementName}, method: ${jAnnotationElement.elementName}"
                    )
                    return false
                }
                val fitRes = booleanArrayOf(false)
                parameters.forEach {
                    if (it.asType().isString()) fitRes[0] = true
                }
                if (!fitRes[0] && needData) {
                    messager.printMessage(
                        Diagnostic.Kind.ERROR,
                        "@JCall 要求被注解函数参数必须有一个 String 类型参数！class: ${jAnnotationElement.enclosingElementName}, method: ${jAnnotationElement.elementName}"
                    )
                    return false
                }
            }
        }
        return true
    }

    /**
     * @author YYQ
     * @date 2022/4/24  11:19
     * @description 检查类型是否为 可执行的Method
     */
    private fun checkElementIsExecuteMethod(jAnnotationElement: JAnnotationElement): Boolean {
        return jAnnotationElement.elementKind == ElementKind.METHOD && jAnnotationElement.elementType.kind == TypeKind.EXECUTABLE
    }

    private fun TypeMirror.isString(): Boolean = toString() == Constants.string.toString()

    private fun TypeMirror.isCallBackFunction(): Boolean =
        toString() == Constants.callBackFunction.toString()

}
